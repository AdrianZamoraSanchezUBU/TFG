\capitulo{3}{Conceptos teóricos}

\subsection{Sobre lenguajes}
\begin{description}
    \item [Clasificación de lenguajes]: Los lenguajes de programación suelen clasificarse según su nivel de abstracción (alto o bajo nivel), paradigma (imperativo, declarativo, OOP, funcional), propósito del lenguaje (propósito general, lenguaje específico del dominio) y por forma de ejecución (compilados o interpretados).  
    \item [Tipado]: El tipado de un lenguaje se refiere a la forma en la que se gestionan los tipos de los datos, en los lenguajes con tipado estático, los tipos deben ser definidos en las declaraciones y se hacen comprobaciones estrictas durante las asignaciones, por otro lado, los lenguajes de tipado dinámico permiten declaraciones sin especificar el tipo, en estos lenguajes normalmente se hacen transformaciones de datos en tiempo de ejecución. 
    \item [Lenguaje máquina]: El lenguaje máquina es aquel que puede ser ejecutado por un ordenador, este tipo de lenguaje suele ser generado por un compilador, puesto que sería extremadamente ineficiente de escribir por un ser humano.
    \item [Gramaticas formales]: Las gramáticas formales son estructuras de reglas con las cuales se pueden generar las cadenas de caracteres permitidas por un lenguaje formal, esta gramática no tiene en cuenta el significado de las fórmulas bien formadas, únicamente la admisión de su forma.
\end{description}

\subsection{Sobre compiladores}
\begin{description}
    \item [Compilador por fases]: Es una técnica de construcción de compiladores que destaca por su alta modularidad, cada fase está bien definida y tiene una única responsabilidad, se caracterizan por ser fácilmente modificables y ampliables. 
    \item [Análisis léxico]: Es una fase del proceso de compilación en la cual se analizan las secuencias de caracteres de un texto y se separan en tokens o lexemas. A la herramienta que realiza este proceso se le llama scaner, lexer o tokenizer
    \item [Análsis sintáctico]: Esta fase del proceso de compilación trata de agrupar los tokens obtenidos durante el análisis léxico, para ello se vale de reglas que generan otras estructuras de datos (como AST) desde la cadena de tokens.
    \item [AST]: el Abstract Syntax Tree (árbol de sintaxis abstracta), es una estructura de datos que se utiliza comúnmente en compiladores para representar producciones sintácticas, donde los tokens forman una estructura gerárquica de árbol que representa el programa y ayuda a su posterior interpretación.
    \item [Tabla de símbolos]: Es una estructura de datos utilizada en compiladores para asociar cada símbolo de un programa con su ubicación, alcance y tipo de dato. Dentro de un compilador cumple un papel fundamental entre el front end y el back end del compilador.
    \item [Análisis semántico]: Es una fase en la cual el compilador comprueba la corrección de las producciones válidas formadas en el análisis sintáctico, algunas correcciones podrían ser la verificación de tipos y corrección en asignaciones y expresiones. Normalmente en esta fase se separa la información necesaria para rellenar la tabla de símbolos con los datos de los identificadores presentes en el código.
    \item [Generación de código intermedio]: la creación de una representación intermedia o IR por sus siglas en inglés, hace referencia a un código que queda a medio camino entre el código fuente y el código máquina. Especialmente en el caso del IR de LLVM utilizado en este trabajo, esta fase nos permite tener una mejor base para realizar diferentes optimizaciones y conversiones a diferentes formas de lenguaje máquina, según la arquitectura objetivo.
    \item [Optimización]: Esta fase consisten en realizar cambios o mejoras en la forma del lenguaje, sin alterar el significado original. Estas pueden ser eliminaciones de código no alcanzable, redefiniciones de algunas estructuras para evitar generar más variables de las necesarias, gestión eficiente de la memoria, etc.
    \item [Generación de código final]: Esta es la fase final del proceso de compilación, durante este paso se convierte el IR a código máquina, el cual está totalmente listo para ser ejecutado.
\end{description}