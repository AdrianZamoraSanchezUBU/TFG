\capitulo{4}{Técnicas y herramientas}

Este capítulo se divide en dos bloques principales: en primer lugar, se describe la metodología seguida durante el desarrollo del proyecto, tanto a nivel organizativo como técnico; en segundo lugar, se presentan las herramientas y tecnologías empleadas.

\section{Metodología de desarrollo}
El desarrollo del proyecto se ha organizado siguiendo una metodología ágil inspirada en el marco de trabajo \textbf{SCRUM}, apoyado en la herramienta \textbf{ZenHub} para su gestión y seguimiento. La elección de una metodología ágil se justifica por su \textit{flexibilidad} y \textit{adaptabilidad}, características que son especialmente valoradas en un contexto tan experimental como lo es el diseño e implementación de un lenguaje de programación.

El flujo de trabajo se estructura mediante un tablero \textbf{Kanban} en ZenHub, el cual permite visualizar de manera clara el estado actual del proyecto. En dicho tablero se gestionan las \emph{issues} y los \emph{milestones} de GitHub, representando las distintas tareas, etapas o funcionalidades en desarrollo.  
Cada elemento del tablero incluye información relevante como la prioridad, la duración estimada, el tipo de tarea y su relación con otras, lo que facilita la planificación y el control del progreso de manera visual y dinámica.

Esta metodología fomenta un desarrollo incremental y una mejora continua del código, permitiendo incorporar nuevas funcionalidades, corregir errores y ajustar los objetivos a medida que avanza el trabajo, garantizando así un resultado más coherente y alineado con los objetivos técnicos del proyecto.

\imagen{zenhub_kanban}{Imagen con la visualización del tablero Kanban en ZenHub}{1.1}

\section{Metodología de programación}
El desarrollo del compilador y de las herramientas asociadas se ha abordado desde el paradigma de la \textbf{programación orientada a objetos} (OOP, por sus siglas en inglés), reflejándose directamente en la estructura del código y en la organización de los distintos módulos del compilador. De forma más concreta, esta metodología permite la incorporación del patrón \eng{\textbf{visitor}}, el cual puede encontrar detallado en el anexo de diseño.

La OOP favorece la reutilización, extensibilidad y mantenibilidad del software, permitiendo aislar los distintos módulos del compilador y facilitar su evolución futura. Además, este paradigma se integra de forma natural con las herramientas empleadas, como \textbf{ANTLR}~\cite{parr2013definitive} y \textbf{LLVM}~\cite{lattner2004llvm}, ambas diseñadas con arquitecturas orientadas a objetos.

Otro motivo determinante en la elección de este enfoque es el uso de \textbf{C++}~\cite{stroustrup2013cpp} como lenguaje de implementación. Este lenguaje ofrece un control preciso sobre el uso de memoria y las abstracciones de bajo nivel, aspectos especialmente relevantes en la implementación de compiladores y runtimes personalizados. Además, la compatibilidad de la metodología OOP entre C++ y las herramientas ANTLR y LLVM refuerza aún más la idoneidad de esta metodología para el proyecto.

La trazabilidad y el control de versiones del código se han gestionado mediante la herramienta \textbf{Git} y el repositorio remoto en \textbf{GitHub}, lo que permite registrar de forma precisa la evolución del proyecto y consultar en todo momento los cambios realizados desde su inicio.

Dado que el desarrollo del proyecto ha sido llevado a cabo de forma individual y siguiendo un flujo de trabajo mayoritariamente lineal, se ha optado por un modelo de trabajo simplificado basado en una única rama principal. Esta decisión permite mantener un historial de cambios claro y fácilmente interpretable, sin introducir la complejidad adicional asociada a la gestión de múltiples ramas, la cual resulta especialmente útil en entornos colaborativos pero menos relevante en un contexto de desarrollo individual.

\section{Calidad del código}
Para el análisis estático del código fuente escrito en C++, se ha utilizado la herramienta \textbf{Cppcheck}. Esta herramienta permite detectar errores comunes de programación, posibles accesos inválidos a memoria, usos indebidos de punteros, fugas de memoria, etc. 

La elección de Cppcheck frente a otras soluciones más completas, como SonarQube, responde principalmente a criterios de accesibilidad y adecuación al contexto del proyecto. Aunque otras plataformas ofrecen análisis avanzados, en la práctica el soporte completo para C++ suele estar restringido a versiones comerciales de pago. Dado el carácter académico del proyecto, se ha considerado poco razonable asumir estos costes adicionales únicamente para el análisis estático del código, optando por una herramienta libre, ampliamente utilizada y suficientemente robusta para los objetivos del proyecto.

De forma complementaria, se ha seguido el \textbf{estándar de estilos de C++} propuesto por el proyecto LLVM~\cite{llvmproject-style-guide}. Este estándar proporciona un conjunto de convenciones claras y coherentes sobre nomenclatura, organización del código, formato y buenas prácticas. La adopción de este estilo resulta especialmente apropiada dado que el proyecto hace uso intensivo de la infraestructura LLVM, alineando así tanto el diseño interno como las herramientas empleadas con los estándares del propio ecosistema.

\section{Elección de herramientas}
A continuación se presentan las principales herramientas empleadas en el desarrollo del proyecto, así como la justificación de su elección frente a otras alternativas disponibles. Las herramientas seleccionadas se han escogido teniendo en cuenta su madurez, soporte, documentación, integración con C++ y adecuación a los objetivos técnicos del proyecto.

\subsection{ANTLR}
ANTLR (\eng{Another Tool for Language Recognition}) es una herramienta ampliamente utilizada para la generación automática de analizadores léxicos y sintácticos a partir de gramáticas formales. Su principal fortaleza radica en la facilidad con la que permite definir y mantener gramáticas complejas mediante una sintaxis clara y expresiva, generando código eficiente y legible para distintos lenguajes de programación, incluido C++.

Entre sus características más destacables se encuentran:
\begin{itemize}
    \item Soporte nativo para gramáticas LL(*)~\cite{parr2011ll} que permiten manejar ambigüedades complejas.
    \item Generación automática de analizadores léxicos y sintácticos a partir de un único archivo de gramática.
    \item Aunque fue diseñado para usarse principalmente en el entorno Java, actualmente cuenta con compatibilidad para muchos lenguajes de destino, entre ellos C++.
\end{itemize}

\textbf{Alternativas consideradas:}
\begin{itemize}
    \item \textbf{Bison~\cite{donnelly1988bison} y Flex~\cite{paxson1995flex}:} Son las herramientas clásicas en la generación de analizadores. Sin embargo, en el contexto elegido ANTLR cuenta con una estructura orientada a objetos más integrable con otras herramientas.
    \item \textbf{PEG (\eng{Parsing Expression Grammar})~\cite{ford2004parsing}:} Ofrecen gran expresividad y flexibilidad, pero carecen del soporte multiplataforma y de la madurez de ANTLR, además de no integrarse de forma fácil con C++.
    \item \textbf{JavaCC~\cite{javacc}:} Alternativas orientadas a Java, no adecuadas para este proyecto al estar centrado en C++.
\end{itemize}

\textbf{Justificación de la elección:}  
ANTLR se considera la opción más equilibrada entre facilidad de uso, potencia y soporte técnico. Permite definir la gramática del lenguaje de manera declarativa y coherente, integrándose perfectamente con el entorno C++ mediante un runtime específico para este lenguaje. Además, ANTLR permite generar automáticamente componentes como los contextos, \textit{visitors} y \textit{listeners}, lo que facilita enormemente la construcción del AST.

\subsection{LLVM}
LLVM (\eng{Low Level Virtual Machine})~\cite{lattner2004llvm,llvmproject,lattner2008llvm} es una infraestructura modular y extensible para el desarrollo de compiladores, enlazadores y optimizadores de código. En este proyecto, LLVM se utiliza principalmente como una frontera entre las primeras fases de análisis y la generación de código máquina. El uso de LLVM IR permite validar la corrección del código generado, aplicar optimizaciones estándar y delegar la generación de código específico de arquitectura a la infraestructura de LLVM, reduciendo la complejidad de implementación y garantizando el soporte multiplataforma.

Entre sus principales ventajas destacan:
\begin{itemize}
    \item \textbf{Representación intermedia (IR):} Permite una separación clara entre la fase de análisis y la de generación de código, haciendo posible optimizaciones y traducciones a múltiples arquitecturas.
    \item \textbf{Portabilidad:} LLVM IR puede compilarse a diferentes arquitecturas (x86, ARM, RISC-V, etc.) sin modificaciones adicionales en el compilador.
    \item \textbf{Integración con C++:} Al estar implementado en C++, se integra de manera natural con el entorno de desarrollo del proyecto.
    \item \textbf{Extensibilidad:} Su diseño modular permite hacer cambios como optimizaciones, cambio de generación de código final o cambios en herramientas de análisis de forma sencilla.
\end{itemize}

\textbf{Alternativas consideradas:}
\begin{itemize}
    \item \textbf{GCC (\eng{GNU Compiler Collection})~\cite{gcc_project}:} Ofrece una infraestructura madura, pero su API interna no está diseñada para un uso con otras herramientas, lo que dificulta su integración en proyectos ajenos al entorno GNU.
    \item \textbf{QBE Compiler Infrastructure~\cite{qbe}:} Es más ligera que LLVM, pero carece del ecosistema, documentación y soporte de comunidad que caracterizan a LLVM.
    \item \textbf{Cranelift~\cite{cranelift}:} Un \eng{backend} moderno y rápido, pero enfocado en compilación JIT (\eng{just-in-time}) y no tan versátil para la generación de IR o compiladores tradicionales.
\end{itemize}

\textbf{Justificación de la elección:}  
LLVM ofrece el equilibrio ideal entre potencial, documentación y flexibilidad, su diseño modular permite construir un compilador completamente funcional sin preocuparse por la dependencia de la arquitectura de destino. Además, su integración con C++ simplifica enormemente la generación de IR y la gestión de optimizaciones.

\subsection{Entorno WSL}
\textbf{Justificación de la elección:}  
El entorno Linux (conseguido mediante WSL) es especialmente sencillo para trabajar con las dependencias de este proyecto sin requerir capas de compatibilización adicionales requeridas por Windows (como MSYS2~\cite{msys2} o MinGW~\cite{mingw}). 

Sus principales ventajas frente a Windows:
\begin{itemize}
    \item \textbf{Simplicidad:} Con un entono únicamente de CLI permite un gran rendimiento y mantiene un entorno coherente con el desarrollo de un compilador, evitando elementos innecesarios que puedan interferir con el desarrollo del proyecto.
    \item \textbf{\eng{Shell scripting}:} Permite crear rutinas de ejecución sencillas que ahorran repetir trabajo a la hora de compilar y probar código.
    \item \textbf{Integración:} Todos los paquetes están preparados para su uso en Unix-like, no se requiere ningún parche para compatibilizar las herramientas entre si. Gran parte del software viene preinstalado en muchas distribuciones de Linux.
\end{itemize}

\subsection{Visual Studio Code}
\textbf{Justificación de la elección:}  
La elección de Visual Studio Code como IDE se da por su simpleza y conocimiento previo, evitando tener que aprender sobre cómo usar un IDE más específico como Visual Studio, pero a su vez potente gracias a su sistema de extensiones, que permite modificarlo según las necesidades del desarrollo. 

En mi caso lo he personalizado con las siguientes extensiones:
\begin{itemize}
    \item \textbf{WSL:} Permite la integración con WSL como si se tratase del sistema host.
    \item \textbf{CMake y CMake Tools:} Permite ejecutar las rutinas de CMake creadas en el proyecto.
    \item \textbf{\LaTeX{} Workshop:} Integración con \LaTeX{} y comodidad de compilación al guardar los archivos para ver los cambios inmediatamente.
    \item \textbf{C/C++ Extension pack:} Agrega IntelliSense, linting, herramientas de debugging y code browsing para C y C++. 
    \item \textbf{Clang-Format:} Herramienta configurable que permite establecer reglas de estilo consistentes en todos los archivos de código, en mi caso utilizo el estándar de LLVM.  
\end{itemize}
 
\subsection{Despliegue con Docker}
\textbf{Justificación de la elección:}  
Con el objetivo de facilitar el acceso y la prueba del compilador desarrollado, se ha optado por proporcionar un entorno de ejecución reproducible mediante el uso de Docker. Esta decisión permite desacoplar el proceso de evaluación del proyecto de la configuración concreta del sistema anfitrión, evitando problemas derivados de dependencias, versiones de las herramientas o problemas derivados del sistemas operativo anfitrión.

Docker se utiliza en este proyecto como un \textbf{entorno de despliegue y ejecución}, no como entorno de desarrollo. El contenedor incluye únicamente lo necesario para la ejecución del compilador (binario del compilador y objetos del \eng{runtime}), junto con las dependencias dinámicas requeridas, evitando la inclusión de herramientas de desarrollo o ficheros auxiliares generados durante la compilación.

Las principales ventajas de Docker son:
\begin{itemize}
    \item \textbf{Reproducibilidad:} Cualquier usuario puede ejecutar el compilador en un entorno idéntico al utilizado durante el desarrollo, independientemente del sistema anfitrión.
    \item \textbf{Aislamiento de dependencias:} Se evita la necesidad de instalar manualmente bibliotecas complejas como LLVM o ANTLR.
    \item \textbf{Portabilidad:} El contenedor puede ejecutarse en sistemas anfitrión Linux, Windows o macOS mediante Docker, manteniendo un comportamiento consistente.
    \item \textbf{Simplicidad de evaluación:} El evaluador puede acceder a un entorno interactivo desde el cual compilar y ejecutar programas escritos en el lenguaje desarrollado sin configurar nada.
\end{itemize}

\textbf{Alternativas consideradas:}
\begin{itemize}
    \item \textbf{Ejecución en el sistema anfitrión:}  
    Esta opción requeriría la instalación manual de dependencias complejas como LLVM, ANTLR y el resto de bibliotecas de tiempo de ejecución, además de garantizar compatibilidad de versiones entre todas estas herramientas. Esta propuesta lleva con facilidad a problemas de reproducibilidad.

    \item \textbf{Distribución mediante máquina virtual:}  
    El uso de una máquina virtual permitiría encapsular completamente el entorno de ejecución, pero implica un mayor consumo de recursos y menor comodidad. Por otro lado, Docker ofrece un aislamiento equivalente con un coste significativamente menor.
\end{itemize}