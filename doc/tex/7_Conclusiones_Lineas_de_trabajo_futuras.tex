\capitulo{7}{Conclusiones y líneas de trabajo futuras}
\subsection{Conclusiones}
En conjunto, el proyecto ha permitido cumplir plenamente los objetivos planteados, dando como resultado un compilador funcional, modular y extensible, apoyado en infraestructuras modernas como LLVM y acompañado de un sistema de ejecución propio. A pesar de las limitaciones inherentes al alcance de un Trabajo de Fin de Grado, el trabajo realizado demuestra la viabilidad técnica del enfoque adoptado y constituye una base sólida sobre la que continuar explorando, ampliando y profundizando en este campo.

A nivel personal, he obtenido una valiosa comprensión sobre el funcionamiento los lenguajes de programación así como los procesos de compilación y en menor medida, el proceso de interpretación. Este trabajo me ha hecho lanzar una mirada crítica a herramientas y lenguajes que llevo utilizando desde hace muchos años pero nunca me había atrevido a cuestionarme realmente como operaban fuera de la mirada del programador. 

Estudiar, analizar y comprender el trabajo tan extenso y complejo que supone crear un compilador de la calidad de \texttt{GCC}, \texttt{Javac} o \texttt{Rustc}, también me ha hecho que me sienta agradecido de disponer de acceso a tecnologías tan punteras y sofisticadas de forma totalmente gratuita, puesto que sin estas herramientas no podríamos desarrollar de forma cómoda y eficiente nuestra labor en el desarrollo de software.

\subsection{Líneas de trabajo futuras}
Puesto que el proyecto está extremadamente acotado por su complejidad y el tiempo disponible, considero que hay numerosas lineas de trabajo con las que me gustaría continuar próximamente, algunas de las más destacables:

\begin{itemize}
    \item Migrar de ANTLR a un \eng{lexer} y \eng{parsers} propios. Pese a que ANTLR4 genera analizadores de una calidad comparable a cualquier compilador profesional, la mayoría de grandes compiladores actuales proporcionan sus propias herramientas de análisis, puesto que son mucho más optimizables y personalizables. Además, evitan la inclusión de clases, contextos y símbolos innecesarios que aumentan en algunos casos innecesariamente la complejidad de los compiladores finales.
    \item Ampliar el lenguaje para soportar la metodología OOP, una de las metodologías de la programación más populares y de las que mejor encajan con un lenguaje que pretende modelar estructuras tan complejas como eventos.
    \item Un \eng{runtime} más sofisticado, con mayor precisión en el control del tiempo y rutinas más optimizadas hechas directamente en ensamblador.
    \item Implementar captura de variables para mejorar las funciones, esta característica que implementan la mayoría de compiladores modernos, permiten el uso de variables de alcances superiores dentro de la propia función sin pasar explícitamente los valores a la función.
    Por ejemplo, el siguiente pseudo código sería incorrecto si los compiladores modernos no implementaran captura de variables:
    
\begin{minted}{javascript}
    function makeCounter():
    a = 0

    function counter():
        a = a + 1 // Ocurre captura de la variable a
        return a

    return counter
\end{minted}

En el ejemplo anterior, a no existen el alcance de \mintinline{c}|counter()|, tampoco se pasa como un parámetro, sino que a accesible porque es capturada. Para ello el compilador tomaría toda la información del entorno donde se define la función \mintinline{c}|counter()|.

\begin{minted}{c}
    struct Env_makeCounter {
        a
    }
\end{minted} 

Y posteriormente sustituye la llamada por la misma función reescrita con el entorno siendo accesible mediante paso por parámetro:
\begin{minted}{javascript}
    function counter(env):
        env.a = env.a + 1 // Se reescribe el uso de la variable a
        return env.a
\end{minted} 

    \item Más casos de prueba y casos de prueba más específicos que permitan una depuración enfocada en errores límite y detectar errores complejos, para así poder poder analizarlos y subsanarlos.
    \item Inclusión de bibliotecas/módulos, que permitan a los usuarios escribir sus propios códigos en archivos que posteriormente puedan importar y utilizar, permitiendo una mejor organización del código fuente, así como la reutilización del código y la colaboración entre proyectos. 
    \item \label{capitulo7:lineas_de_trabajo:garbage_collector} Sistema de gestión de memoria (\eng{garbage collector}) capaz de hacer reservas y liberaciones de memoria en \eng{heap}, permitiendo un control más amplio de punteros/referencias, especialmente en el contexto de los programas en ejecución.
    \item Mejor reconocimiento y reporte de errores. Crear un módulo del compilador que se encargue únicamente de esto, permitiendo una mejor separación de responsabilidades y un código más robusto.
\end{itemize}
