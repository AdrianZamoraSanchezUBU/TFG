\capitulo{7}{Conclusiones y líneas de trabajo futuras}
\subsection{Conclusiones}
Tras realizar el proyecto, he conseguido una comprensión profunda sobre como funcionan los lenguajes de programación así como los procesos de compilación y en menor medida el proceso de interpretación. Este trabajo me ha hecho lanzar una mirada crítica a herramientas y lenguajes que llevo usando desde hace muchos años pero nunca me había preguntado realmente como operaban fuera de la mirada del programador. 

Estudiar, analizar y comprender el trabajo tan extenso y complejo que supone crear un compilador de la calidad de GCC o rustc, también me ha hecho que me sienta especialmente agradecido de disponer de acceso a tecnologías tan punteras y sofisticadas de forma totalmente gratuita, estas herramientas nos permiten desarrollar de forma cómoda nuestra labor en el desarrollo de software sin pedir nada a cambio.

\subsection{Líneas de trabajo futuras}
Puesto que el proyecto está extremadamente acotado por su complejidad y el tiempo disponible, considero que hay numerosas lineas de trabajo con las que me gustaría continuar próximamente, algunas de las más destacables:

\begin{itemize}
    \item Migrar de ANTLR a un \eng{lexer} y \eng{parsers} propios. Pese a que ANTLR4 genera analizadores de una calidad comparable a cualquier compilador profesional, la mayoría de grandes compiladores actuales proporcionan sus propias herramientas de análisis, puesto que son mucho más optimizables y personalizables. Además, evitan la inclusión de clases, contextos y símbolos innecesarios que aumentan en algunos casos innecesariamente la complejidad de los compiladores finales.
    \item Ampliar el lenguaje para soportar la metodología OOP, una de las metodologías de la programación más populares y de las que mejor encajan con un lenguaje que pretende modelar estructuras tan complejas como eventos.
    \item Un \eng{runtime} más sofisticado, con mayor precisión en el control del tiempo y rutinas más optimizadas hechas directamente en ensamblador.
    \item Implementar captura de variables para mejorar las funciones, esta característica que implementan la mayoría de compiladores modernos, permiten el uso de variables de alcances superiores dentro de la propia función sin pasar explícitamente los valores a la función.
    Por ejemplo, el siguiente pseudo código sería incorrecto si los compiladores modernos no implementaran captura de variables:
    \begin{verbatim}
        function makeCounter():
        a = 0

        function counter():
            a = a + 1 // Ocurre captura de la variable a
            return a

        return counter
    \end{verbatim} 
    En el ejemplo anterior, a no existen el alcance de counter(), tampoco se pasa como un parámetro, sino que a accesible porque es capturada. Para ello el compilador tomaría toda la información del entorno donde se define la función counter()
    
    \begin{verbatim}
        struct Env_makeCounter {
            a
        }
    \end{verbatim} 

    Y posteriormente sustituye la llamada por la misma función reescrita con el entorno siendo accesible mediante paso por parámetro:
    \begin{verbatim}
        function counter(env):
            env.a = env.a + 1 // Se reescribe el uso de la variable a
            return env.a
    \end{verbatim} 

    \item Más pruebas y tiempo de depuración para poder detectar errores complejos en casos de uso muy específicos, para poder poder analizarlos y subsanarlos.
    \item Inclusión de bibliotecas/módulos, que permitan a los usuarios escribir sus propios códigos en archivos que posteriormente puedan importar y utilizar, permitiendo una mejor organización del código fuente, así como la reutilización del código fuente y la colaboración entre proyectos. 
\end{itemize}