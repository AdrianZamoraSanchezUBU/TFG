\capitulo{5}{Aspectos relevantes del proyecto} 
El comienzo del proyecto parte del objetivo de conseguir una versión MVP (Minimal Viable Product) que pudiese aportar una base sólida y fácil de ampliar. En este caso el MVP se enfocó en la creación de un micro compilador capaz de procesar expresiones aritméticas y lógicas, puesto que esta estructura es básica y está presente en todos los lenguajes de programación.

\subsection{Antes de compilar} % TODO
El compilador antes de comenzar el proceso de compilación debe leer el código de entrada...

\subsection{Proceso de compilación}
Como el compilador se ha planificado como modular, a continuación se recorrerá el proceso de compilación completo con el contenido del MVP. 

\subsubsection{Análisis léxico}
La primera fase de este desarrollo comienza con la creación de un lexer donde se definen algunas estructuras básicas como los literales de números enteros, números con decimales o las cadenas de caracteres, así como los operadores que se van a emplear para estas expresiones. 

En este momento se definen los tipos básicos del lenguaje:
\begin{verbatim}
    TYPE_INT     : 'int'    ;
    TYPE_FLOAT   : 'float'  ;
    TYPE_CHAR    : 'char'   ;
    TYPE_STRING  : 'string' ;
    TYPE_BOOLEAN : 'bool'   ;
    TYPE_VOID    : 'void'   ;
\end{verbatim}

Se definen los operadores aritméticos y lógicos:
\begin{verbatim}
    PLUS  : '+' ;
    MINUS : '-' ;
    MUL   : '*' ;
    DIV   : '/' ;

    EQ : '==' ;
    NE : '!=' ;
    LT : '<'  ;
    LE : '<=' ;
    GT : '>'  ;
    GE : '>=' ;
\end{verbatim}

\subsubsection{Análisis sintáctico}
Una vez obtenido el lexer el siguiente paso es construir un parser capaz de reconocer estructuras gramaticales más complejas donde se conectan el uso de los operadores y los literales definidos anteriormente.

Los operadores y las operaciones sobre estas estructuras de definen en el lenguaje ANTLR4 de la siguiente forma:
\begin{verbatim}
expr
    : expr op=(MUL|DIV) expr        # arithmeticExpr
    | expr op=(PLUS|MINUS) expr     # arithmeticExpr
    | expr comparisonOperator expr  # logicalExpr
    | operand                       # operandExpr
    | LPAREN expr RPAREN            # parenExpr
    ;

comparisonOperator
    : EQ 
    | NE
    | LT 
    | LE 
    | GT
    | GE
    ;

operand
    : literal
    ;
\end{verbatim}

A continuación se debe implementar una estructura de datos que sea capaz de representar cualquier tipo de estructura sintáctica bien formada de este lenguaje, la estructura del árbol de sintaxis abstracta (AST por sus siglas en inglés) será la encargada de crear este representacion en tiempo de ejecución del compilador, almacenando los datos relevantes de cada estructura para su posterior análisis en las siguientes fases.

Para formar este AST se empleará un visitor patterns (patrón de visita), objeto que recibe el nombre de ASTBuilder, el cual se encarga de visitar cada contexto generado de forma automática por el parser de ANTLR, dando por resultado unos nodos enlazados, el AST.


Adicionalmente, ASTBuilder será el encargado de generar una representación visual del árbol a medida que lo va construyendo, para conseguir esto se escriben cada nodo en el formato de la biblioteca `forest` de LaTex a medida que estos se van formando, garantizando su orden y asociación correctos.

\imagen{AST_ejemplo_expr}{Ejemplo de expresión 2 + 3 * 5}{0.55}

\subsubsection{Análisis semántico}
Durante la fase de análisis semántico se examina principalmente el uso de los identificadores, como los nombres de variables y funciones. Entre las comprobaciones más relevantes se incluyen:
\begin{itemize}
    \item La creación de un scope para cada bloque de código.
    \item La inserción de los identificadores en su scope correspondiente.
    \item La verificación del alcance en cada acceso a un identificador.
    \item Las comprobaciones de tipos en asignaciones, operaciones y sentencias de retorno.
\end{itemize}

La tabla de símbolos está estructurada como una lista de scopes. Para los distintos bloques anidados se establecen referencias entre cada scope hijo y su scope padre, lo que permite verificar fácilmente los alcances y resolver identificadores de forma correcta.

Para poder comprobar la corrección del uso de tipos, el análisis semántico debe ser capaz de entender los tipos, tanto de los literales como de las variables y funciones, para ello se implementa un sistema de representación de tipos en una enumeración llamada SupportedTypes que da soporte a los tipos:
\begin{itemize}
    \item TYPE\_INT
    \item TYPE\_FLOAT
    \item TYPE\_CHAR
    \item TYPE\_STRING
    \item TYPE\_BOOLEAN
    \item TYPE\_VOID
\end{itemize}

\subsubsection{Generación de LLVM IR}
Para la generación de IR es emplea un struct que almacena los datos necesarios para que LLVM pueda generar el IR de forma automática, para ello se inicializan dentro del CodegenContext los siguientes tres elementos:

\begin{itemize}
    \item Un módulo de LLVM
    \item Un contexto de LLVM
    \item Un builder de LLVM
\end{itemize}

Durante el proceso de generación de código IR, se vuelve a recorer el AST con un visitor pattern, el cual emplea principalmente el builder para generar las instrucciones a partir de los datos contenidos en los nodos del AST.

Algunas de las consideraciones necesarias para compatibilizar el AST y el generación de IR serían los tipos que se manejan en cada uno, para poder hacer una conversión correcta se implementa una función capaz de transformar:
\begin{table}[ht]
    \centering
    \begin{tabularx}{\linewidth}{ p{0.5\columnwidth} p{0.5\columnwidth} }
    \toprule
    \textbf{Tipo AST} & \textbf{Tipo LLVM} \\
    \midrule
    TYPE\_INT     & i32 \\
    TYPE\_FLOAT   & float \\
    TYPE\_CHAR    & i8 \\
    TYPE\_STRING  & i8* \\
    TYPE\_BOOLEAN & i1 \\
    TYPE\_VOID    & void \\
    \bottomrule
    \end{tabularx}
    \caption{Correspondencia entre tipos del AST y tipos de LLVM IR}
\end{table}


\subsubsection{Optimizaciones} % TODO
TODO

\subsubsection{Generación del ejecutable} % TODO
TODO