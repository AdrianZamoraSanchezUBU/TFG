\capitulo{5}{Aspectos relevantes del proyecto} 

\newcommand{\kw}[1]{\texttt{#1}}
\newcommand{\fn}[1]{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}

El comienzo del proyecto parte del objetivo de conseguir una versión MVP \emph{Minimal Viable Product} que pudiese aportar una base sólida y fácil de ampliar. En este caso el MVP se enfocó en la creación de un micro compilador capaz de procesar expresiones aritméticas y lógicas, puesto que esta estructura es básica que está presente en todos los lenguajes de programación.

\subsection{Antes de compilar} 
El compilador antes de comenzar el proceso de compilación debe recibir en su ejecución datos que hagan referencia al archivo que se debe compilar, que archivo de salida se quiere generar y de que forma se debe realizar el proceso, permitiendo así al programador ajustar este proceso a sus necesidades.

Dentro del compilador se esperan algunos argumentos de llamada como:
\begin{itemize}
    \item \textbf{<nombre de la entrada>}: argumento obligatorio, indica el nombre del fichero .T de entrada.
    \item \textbf{-o <nombre archivo>}: argumento obligatorio que especificar el fichero ejecutable de salida.
    \item \textbf{--debug}: permite ver información de la salida de cada una de las fases del compilador. Este argumento también activa el efecto del argumento \emph{--visualizeAST};
    \item \textbf{--visualizeAST}: genera un fichero \fn{AST.pfd} con una visualización del AST en el directorio donde se ha ejecutado el compilador.
    \item \textbf{--IR <nombre archivo>}: genera un fichero .ll con el LLVM IR generado por el compilador.
    \item \textbf{--help / -h}: genera un fichero .ll con el LLVM IR generado por el compilador.
    \item \textbf{--version / -v}: muestra la versión actual del compilador.
\end{itemize}

Para conocer los datos necesarios para ejecutar los comandos anteriores en el compilador se almacenan flags de compilado que permiten modificar el comportamiento de cada fase.

\subsection{Proceso de compilación}
Como el compilador se ha planificado de forma modular, a continuación se recorrerá el proceso de compilación completo, valiéndonos del contenido del MVP, es decir, un compilador capaz de reconocer expresiones aritméticas y lógicas. 

\subsubsection{Análisis léxico}
La primera fase de este desarrollo comienza con la creación de un lexer donde se definen algunas estructuras básicas como los literales de números enteros, números con decimales o las cadenas de caracteres, así como los operadores que se van a emplear para estas expresiones. 

En este momento se definen las palabras clave asociadas a los tipos básicos del lenguaje:
\begin{verbatim}
    TYPE_INT     : 'int'    ;
    TYPE_FLOAT   : 'float'  ;
    TYPE_CHAR    : 'char'   ;
    TYPE_STRING  : 'string' ;
    TYPE_BOOLEAN : 'bool'   ;
    TYPE_VOID    : 'void'   ;
    TYPE_PTR     : 'ptr'    ;
\end{verbatim}

Se definen los operadores aritméticos y lógicos:
\begin{verbatim}
    PLUS  : '+' ;
    MINUS : '-' ;
    MUL   : '*' ;
    DIV   : '/' ;

    INC   : '++' ;
    DEC   : '--' ;

    EQ : '==' ;
    NE : '!=' ;
    LT : '<'  ;
    LE : '<=' ;
    GT : '>'  ;
    GE : '>=' ;
\end{verbatim}

\subsubsection{Análisis sintáctico}
Una vez obtenido el lexer el siguiente paso es construir un parser capaz de reconocer estructuras gramaticales más complejas donde se conectan el uso de los operadores y los literales definidos anteriormente.

Los operadores y las operaciones sobre estas estructuras de definen en el lenguaje ANTLR4 de la siguiente forma:
\begin{verbatim}
expr
    : expr op=(MUL|DIV) expr        # arithmeticExpr
    | expr op=(PLUS|MINUS) expr     # arithmeticExpr
    | expr comparisonOperator expr  # logicalExpr
    | operand                       # operandExpr
    | LPAREN expr RPAREN            # parenExpr
    ;

comparisonOperator
    : EQ 
    | NE
    | LT 
    | LE 
    | GT
    | GE
    ;

operand
    : literal
    ;
\end{verbatim}
Cabe destacar el uso de etiquetas (como \kw{\# parenExpr}) que facilitan posteriormente acceder a cada tipo de expresión gracias a la separación en contextos que realiza ANTLR4.

A continuación se debe implementar una estructura de datos que sea capaz de representar cualquier tipo de estructura sintáctica bien formada de este lenguaje, la estructura del árbol de sintaxis abstracta (AST por sus siglas en inglés) será la encargada de crear este representacion en tiempo de ejecución del compilador, almacenando los datos relevantes de cada estructura para su posterior análisis en las siguientes fases.

Para formar este AST se empleará un visitor patterns (patrón de visita), objeto que recibe el nombre de \kw{ASTBuilder}, el cual se encarga de visitar cada contexto generado de forma automática por el parser de ANTLR, dando por resultado unos nodos enlazados, el AST.


Adicionalmente, si la flag \kw{--visualizeAST} está activada, el compilador puede generar una representación visual del árbol tras su construcción, para conseguir esto se escriben cada nodo en el formato de la biblioteca `forest` de \LaTeX, permitiendo el análisis de la estructura del programa así como datos relacionados con los componentes, como los tipos u operadores.

\imagen{AST_ejemplo_expr}{Ejemplo de visualización de la expresión 2 + 3 * 5 con la flag \emph{--visualizeAST}}{0.55}

\subsubsection{Análisis semántico}
Durante la fase de análisis semántico se examina principalmente el uso de los identificadores, como los nombres de variables y funciones. Entre las comprobaciones más relevantes se incluyen:
\begin{itemize}
    \item La creación de un scope para cada bloque de código.
    \item La inserción de los identificadores en su scope correspondiente.
    \item La verificación del alcance en cada acceso a un identificador.
    \item Las comprobaciones de tipos en asignaciones, operaciones y sentencias de retorno.
\end{itemize}

La tabla de símbolos está estructurada como una lista de scopes. Para los distintos bloques anidados se establecen referencias entre cada scope hijo y su scope padre, lo que permite verificar fácilmente los alcances y resolver identificadores de forma correcta.

\imagen{symbol_table}{Ejemplo de la visualización de una tabla de símbolos \emph{--visualizeAST}}{0.55}

Para poder comprobar la corrección del uso de tipos, el análisis semántico debe ser capaz de entender los tipos, tanto de los literales como de las variables y funciones, para ello se implementa un sistema de representación de tipos en una enumeración llamada \kw{SupportedTypes} que da soporte a los tipos:
\begin{itemize}
    \item \kw{TYPE\_INT}
    \item \kw{TYPE\_FLOAT}
    \item \kw{TYPE\_CHAR}
    \item \kw{TYPE\_STRING}
    \item \kw{TYPE\_BOOLEAN}
    \item \kw{TYPE\_VOID}
    \item \kw{TYPE\_PTR}
\end{itemize}

\subsubsection{Librería estándar}
Para permitir mayor flexibilidad al programador, todas las funciones de la librería estándar de C son enlazadas con el programa final generado. Adicionalmente, se agregan o adaptan algunas funciones para crear una pequeña librería propia, que demuestra la capacidad del compilador de incluir funciones preinstaladas o \emph{built-in functions}.

\begin{itemize}
    \item \code{char *toString(int x)}
    \item \code{void print(const char *first, ...)}
\end{itemize}

La función antes mencionada, \code{char* toString(int x)}, aprovecha internamente funciones estándar de C como \code{sprintf} para devolver un buffer de tipo \code{char *} sin tener que reinventar este mecanismo y a su vez abstrayendo al programador del uso de estas funciones y el manejo de memoria. 

\subsubsection{Generación de LLVM IR}
Para la generación de IR es emplea un struct que almacena los datos necesarios para que LLVM pueda generar el IR de forma automática, para ello se inicializan dentro del \kw{CodegenContext} los siguientes tres elementos:

\begin{itemize}
    \item Un módulo de LLVM
    \item Un contexto de LLVM
    \item Un builder de LLVM
\end{itemize}

Durante el proceso de generación de código IR, se vuelve a recorrer el AST con un visitor pattern, el cual emplea principalmente el builder para generar las instrucciones a partir de los datos contenidos en los nodos del AST.

Algunas de las consideraciones necesarias para compatibilizar el AST y el generación de IR serían los tipos que se manejan en cada uno, para poder hacer una conversión correcta se implementa una función capaz de transformar:
\begin{table}[ht]
    \centering
    \begin{tabularx}{\linewidth}{ p{0.5\columnwidth} p{0.5\columnwidth} }
    \toprule
    \textbf{Tipo AST} & \textbf{Tipo LLVM} \\
    \midrule
    \kw{TYPE\_INT}    & \kw{i32} \\
    \kw{TYPE\_FLOAT}   & \kw{float} \\
    \kw{TYPE\_CHAR}    & \kw{i8} \\
    \kw{TYPE\_STRING}  & \kw{i8*} \\
    \kw{TYPE\_BOOLEAN} & \kw{i1} \\
    \kw{TYPE\_VOID}    & \kw{void} \\
    \kw{TYPE\_PTR}     & \kw{ptrType} \\
    \bottomrule
    \end{tabularx}
    \caption{\texorpdfstring{Correspondencia entre tipos del AST y tipos de LLVM IR}{Correspondencia entre tipos del AST y tipos de LLVM IR}}
\end{table}

Una vez completado el proceso obtendremos un programa equivalente en formato LLVM IR, el cual para este ejemplo concreto es:
\begin{verbatim}
source_filename = "program"

declare ptr @toString(i32)

declare i32 @print(ptr, ...)

declare i32 @strlen(ptr)

declare void @registerEventData(ptr, float, ptr, i32, ptr, i32)

declare void @scheduleEvent(ptr, ptr)

define i32 @mainLLVM() {
entry:
  ret i32 17
}
\end{verbatim}

En este caso vemos una optimización automática de LLVM que se explicará en el siguiente apartado.

\subsubsection{Optimizaciones}
% TODO
Para asegurar la calidad del código final, se aplican sobre el LLVM IR algunas optimizaciones incluidas en la API de LLVM, las cuales aplican transformaciones, inserciones/eliminaciones de código o correcciones mediante passes que recorren todo el programa generado.

Algunas de las más importantes son:
\begin{itemize}
    \item Constant folding: las operaciones calculables en tiempo de compilación se deben realizar en este momento para evitar recalcular en cada ejecución.
    \item Dead code elimination: Aunque se trate de aplicar durante la generación del código, es importante utilizarla para casos donde el código está bien formado pero hay elementos sin usar, como variables o funciones que no sean externas y nunca son llamadas en el programa.
    \item Dead store elimination: Se eliminan escrituras en memoria que nunca son leídas, ahorrando recursos internos.
    \item Dead argument elimination: Esta optimización específica de las funciones permite eliminar los argumentos no utilizados, simplificando el programa.
\end{itemize}

En el ejemplo con el que estamos trabajando, podemos observar un ejemplo de \emph{constant folding}, donde la expresión original \emph{return 2+3*5;} puede ser traducida a \emph{return 2+15;} y finalmente \emph{return 17;}, obteniendo de esta manera un \emph{return statement} exento de cálculos.

El uso de estas combinaciones junto a las comprobaciones de calidad mínimas para compilar sin errores, generan un código de una calidad similar al código optimizado con \code{-O2} de compiladores como Clang, Rustc o Swiftc.

Este ejemplo ilustra cómo las optimizaciones permiten simplificar significativamente el código generado, reduciendo tanto el número de instrucciones como la complejidad del flujo de control, sin alterar el comportamiento del programa.
\textbf{Código fuente original:}
\begin{verbatim}
if (2 < 3) {
    return 1;
}

return 2;
\end{verbatim}

\textbf{LLVM IR generado sin optimizaciones:}

En una primera fase, el generador de IR traduce directamente la estructura del programa fuente, manteniendo el flujo de control explícito mediante saltos condicionales.

\begin{verbatim}
define i32 @mainLLVM() {
entry:
  br i1 true, label %then, label %endif
then:
  ret i32 1
endif:
  ret i32 2
}
\end{verbatim}

Puede observarse que la condición \texttt{2 < 3} se evalúa en tiempo de compilación mediante una optimización de \emph{constant folding}, sustituyendo la condición por un valor constante (\texttt{true}).

\textbf{LLVM IR tras la fase de optimización:}

Durante la fase de optimización, el compilador analiza el flujo de control del programa y detecta que todas las rutas de ejecución alcanzables conducen al mismo valor de retorno. Como consecuencia, el bloque condicional completo puede eliminarse, reduciendo la función a una única instrucción de retorno.

\begin{verbatim}
define noundef i32 @mainLLVM() local_unnamed_addr #0 {
entry:
  ret i32 1
}
\end{verbatim}

\subsubsection{Generación del ejecutable}
La generación de un programa requiere conocer el "target triplet", es decir, la familia de CPU en la que se ejecuta el sistema. La API del sistema \code{llvm::sys} de LLVM contiene funciones que nos permiten conocer el triplet y así poder establecer un data layout correcto para el sistema en el que estamos trabajando.   

Una vez hemos generado el código objeto del programa, el compilador ejecuta un enlace utilizando la herramienta clang++, de forma que el archivo generado se enlaza con la librería estándar del compilador, la librería estándar de C y el \emph{runtime}. 

\subsection{Runtime}
El runtime es una parte necesaria para la ejecución de cualquier programa, normalmente aporta un punto de entrada valido mediante un system call en ensamblador.

Además aporta un entorno de ejecución correcto y personalizado para poder llevar a cabo acciones concretas, en el caso de este lenguaje, es el runtime el responsable de tener en cuenta los eventos generados para su planificación y ejecución.